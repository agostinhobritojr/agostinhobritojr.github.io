#include <iostream>
#include <opencv2/opencv.hpp>
#include <opencv2/imgproc/imgproc.hpp>

#define RADIUS 20

using namespace cv;
using namespace std;



// troca os quadrantes da imagem da DFT
void deslocaDFT(Mat& image ){
  Mat tmp, A, B, C, D;

  // se a imagem tiver tamanho impar, recorta a regiao para
  // evitar cópias de tamanho desigual
  image = image(Rect(0, 0, image.cols & -2, image.rows & -2));
  int cx = image.cols/2;
  int cy = image.rows/2;
  
  // reorganiza os quadrantes da transformada
  // A B   ->  D C
  // C D       B A
  A = image(Rect(0, 0, cx, cy));
  B = image(Rect(cx, 0, cx, cy));
  C = image(Rect(0, cy, cx, cy));
  D = image(Rect(cx, cy, cx, cy));

  // A <-> D
  A.copyTo(tmp);  D.copyTo(A);  tmp.copyTo(D);

  // C <-> B
  C.copyTo(tmp);  B.copyTo(C);  tmp.copyTo(B);
}

int main(int argc, char** argv){
  Mat imaginaryInput, complexImage, multsp;
  Mat padded, filter, mag;
  Mat image, imageread, imagegray, tmp; 
  Mat_<double> realInput, zeros;
  vector<Mat> planos;
  double max, min;

  // habilita/desabilita ruido
  int noise=0;
  // frequencia do ruido
  int freq=10;
  // ganho inicial do ruido
  double gain=1;

  // valor do ruido
  double mean;

  // guarda tecla capturada
  char key;

  // valores ideais dos tamanhos da imagem
  // para calculo da DFT
  int dft_M, dft_N;

  // abre a imagem
  image = imread(argv[1],CV_LOAD_IMAGE_GRAYSCALE);
  if(!image.data){
	cout << "nao abriu" << argv[1] << endl;
    cout << argv[0] << " imagem.jpg";
  }
  cout << image.rows << "x" << image.cols<< endl;
  //  image = image(Rect(0, 0, image.cols & -2, image.rows & -2));
  cout << image.rows << "x" << image.cols<< endl;
  
  // identifica os tamanhos otimos para
  // calculo do FFT
  dft_M = getOptimalDFTSize(image.rows);
  dft_N = getOptimalDFTSize(image.cols);
  cout << dft_M << "x" << dft_N<< endl;

  // realiza o padding da imagem
  copyMakeBorder(image, padded, 0,
                 dft_M - image.rows, 0,
                 dft_N - image.cols,
                 BORDER_CONSTANT, Scalar::all(0));

  // parte imaginaria da matriz complexa (preenchida com zeros)
  zeros = Mat_<double>::zeros(padded.size());

  // prepara a matriz complexa para ser preenchida
  complexImage = Mat(padded.size(), CV_64FC2, Scalar(0));
  cout << "compleximage" << complexImage.rows << "x" << complexImage.cols<< endl;

  // a função de transferência (filtro frequencial) deve ter o
  // mesmo tamanho e tipo da matriz complexa
  filter = complexImage.clone();

  // cria uma matriz temporária para criar as componentes real
  // e imaginaria do filtro ideal
  tmp = Mat(padded.rows, padded.cols, CV_64F);
  //cout << "padded" << padded.rows << "x" << padded.cols<< endl;

  double gamal, gamah, d0, c;
  gamal = 0.5;
  gamah = 2.0;
  c = 1;
  d0 = 8;
  // prepara o filtro passa-baixas ideal
  for(int i=0; i<dft_M; i++){
    for(int j=0; j<dft_N; j++){
      tmp.at<double> (i,j) = gamal +(gamah - gamal)*(1-exp(-(powf(dft_M/2-i,2)+powf(dft_N/2-j,2))/(d0*d0)));
    }
  }
  minMaxLoc(tmp,&min,&max,0,0,Mat());
  cout << "min-max-tmp: " << min << " " << max << endl;

  imshow("filtro", tmp);

  // cria a matriz com as componentes do filtro e junta
  // ambas em uma matriz multicanal complexa
  Mat comps[]= {tmp, tmp};
  merge(comps, 2, filter);
  
  imshow("original", image);
    
  // limpa o array de matrizes que vao compor a
  // imagem complexa
  planos.clear();
  // cria a compoente real
  realInput = Mat_<double>(padded);
  cout << "realinput" << realInput.rows << "x" << realInput.cols<< endl;

  //  realInput += 1.0;
  //  cv::log(realInput,realInput);
  minMaxLoc(realInput,&min,&max,0,0,Mat());
  cout << "min-max-log: " << min << " " << max << endl;

  // insere as duas componentes no array de matrizes
  planos.push_back(realInput);
  planos.push_back(zeros);
  
  // combina o array de matrizes em uma unica
  // componente complexa
  merge(planos, complexImage);
  
  // calcula o dft
  dft(complexImage, complexImage);
  
  // realiza a troca de quadrantes
  deslocaDFT(complexImage);

  cout << complexImage.rows << "x" << complexImage.cols<< endl;
  
  // aplica o filtro frequencial
  mulSpectrums(complexImage,filter,complexImage,0);
  
  // troca novamente os quadrantes
  deslocaDFT(complexImage);
  
  cout << complexImage.size().height << endl;
  // calcula a DFT inversa
  idft(complexImage, complexImage, DFT_SCALE);
  
  // limpa o array de planos
  planos.clear();
  
  // separa as partes real e imaginaria da
  // imagem filtrada
  split(complexImage, planos);
  minMaxLoc(planos[0],&min,&max,0,0,Mat());
  cout << "min-max-idft-orig: " << min << " " << max << endl;
  normalize(planos[0], planos[0], 0, 0.001, CV_MINMAX);
  minMaxLoc(planos[0],&min,&max,0,0,Mat());
  cout << "min-max-idft: " << min << " " << max << endl;
  exp(planos[0],planos[0]);    
  minMaxLoc(planos[0],&min,&max,0,0,Mat());
  cout << "min-max-idft-exp: " << min << " " << max << endl;
  // normaliza a parte real para exibicao
  normalize(planos[0], planos[0], 0, 1, CV_MINMAX);
  imshow("filtrada", planos[0]);
  
  key = (char) waitKey();
  
  return 0;
}
